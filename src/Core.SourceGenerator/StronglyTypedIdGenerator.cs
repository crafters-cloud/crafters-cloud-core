using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CraftersCloud.Core.SourceGenerator;

[Generator]
public class StronglyTypedIdGenerator : IIncrementalGenerator
{
    private const string AttributeName = "StronglyTypedIdAttribute";
    private const string AttributeNamespace = "CraftersCloud.Core.StronglyTypedIds";

    private const string _attributeText = $$"""
                                            // <auto-generated />
                                            using System;

                                            #pragma warning disable 1591

                                            namespace {{AttributeNamespace}}
                                            {
                                                public enum ValueKind
                                                {
                                                    Guid = 0,
                                                    Int = 1,
                                                }
                                            
                                                [AttributeUsage(AttributeTargets.Struct, Inherited = false, AllowMultiple = false)]
                                                internal sealed class {{AttributeName}}(ValueKind valueKind) : Attribute
                                                {
                                                    public ValueKind ValueKind { get; } = valueKind;
                                                }
                                            }

                                            """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource($"{AttributeName}.g.cs", _attributeText));

        var stronglyTypedIdClasses = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                $"{AttributeNamespace}.{AttributeName}",
                static (s, _) => IsSyntaxTargetForGeneration(s),
                static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null)
            .Collect();

        context.RegisterSourceOutput(stronglyTypedIdClasses, Execute);
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node) =>
        node is RecordDeclarationSyntax recordDeclarationSyntax
        && recordDeclarationSyntax.Modifiers.Any(SyntaxKind.PartialKeyword);

    private static INamedTypeSymbol? GetSemanticTargetForGeneration(GeneratorAttributeSyntaxContext context)
    {
        var symbol = context.TargetSymbol;

        if (symbol is not INamedTypeSymbol namedTypeSymbol)
        {
            return null;
        }

        var attributeData = namedTypeSymbol.GetAttributes().FirstOrDefault(IsStronglyTypedAttribute);

        return attributeData is null ? null : namedTypeSymbol;
    }

    private static bool IsStronglyTypedAttribute(AttributeData ad) =>
        string.Equals(ad.AttributeClass?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
            $"global::{AttributeNamespace}.{AttributeName}");

    private static void Execute(SourceProductionContext context, ImmutableArray<INamedTypeSymbol?> symbols)
    {
        foreach (var namedTypeSymbol in symbols.Where(symbol => symbol is not null))
        {
            var classSource = ProcessClass(namedTypeSymbol!, context);

            if (classSource is null)
            {
                continue;
            }

            context.AddSource($"{namedTypeSymbol!.ContainingNamespace}_{namedTypeSymbol.Name}.g.cs", classSource);
        }
    }

    private static string? ProcessClass(INamedTypeSymbol classSymbol, SourceProductionContext context)
    {
        var attributeLocation = classSymbol.Locations.FirstOrDefault() ?? Location.None;

        if (!classSymbol.ContainingSymbol.Equals(classSymbol.ContainingNamespace, SymbolEqualityComparer.Default))
        {
            CreateDiagnosticError(GeneratorDiagnosticDescriptors.TopLevelError);
            return null;
        }

        if (classSymbol.TypeKind != TypeKind.Struct)
        {
            CreateDiagnosticError(GeneratorDiagnosticDescriptors.WrongType);
            return null;
        }

        var attribute = classSymbol.GetAttributes().FirstOrDefault(IsStronglyTypedAttribute);

        return GenerateClassSource(classSymbol, attribute!);

        void CreateDiagnosticError(DiagnosticDescriptor descriptor)
        {
            context.ReportDiagnostic(Diagnostic.Create(descriptor, attributeLocation, classSymbol.Name,
                DiagnosticSeverity.Error));
        }
    }

    private static string GenerateClassSource(INamedTypeSymbol classSymbol, AttributeData attribute)
    {
        var className = $"{classSymbol.Name}";
        var valueKind = (int) attribute.ConstructorArguments[0].Value!;
        var valueType = valueKind switch
        {
            0 => "Guid",
            1 => "Int32",
            _ => throw new InvalidOperationException($"Invalid value valueKind: {valueKind}")
        };
        var valueTypeFactory = valueKind == 0 ? "SequentialGuidGenerator.Generate()" : "default";

        StringBuilder source = new($$"""

                                     // <auto-generated />
                                     #pragma warning disable 1591

                                     using System;
                                     using CraftersCloud.Core.Entities;
                                     using CraftersCloud.Core.StronglyTypedIds;

                                     namespace {{classSymbol.ContainingNamespace.ToDisplayString()}};

                                     readonly partial record struct {{className}}({{valueType}} Value) : IStronglyTypedId<{{valueType}}>
                                     {
                                        public static implicit operator {{valueType}}({{className}} id) => id.Value;
                                     
                                        public override string ToString() => Value.ToString();
                                        
                                        public static {{className}} New() => new({{valueTypeFactory}});
                                        
                                        public static bool TryParse(string value, out {{className}} result)
                                        {
                                            if (!{{valueType}}.TryParse(value, out var val))
                                            {
                                                result = default;
                                                return false;
                                            }
                                         
                                             result = new {{className}}(val);
                                             return true;
                                         }
                                     }
                                     """);

        return source.ToString();
    }
}